<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Klondike Solitaire</title>
  <style>
    :root{
      --bg:#0b6623;
      --card-back:#0c5a3c;
      --card-width:92px;
      --card-height:128px;
      --card-radius:8px;
      --accent:#f0f0f0;
      --red:#d32f2f;
      --black:#222;
      --pile-gap:12px;
    }
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Arial,sans-serif;background:var(--bg);color:var(--accent);-webkit-font-smoothing:antialiased}
    .app{
      max-width:1100px;margin:18px auto;padding:12px;
    }
    header{
      display:flex;align-items:center;gap:12px;margin-bottom:12px;
    }
    header h1{font-size:18px;margin:0;color:var(--accent)}
    .controls{margin-left:auto;display:flex;gap:8px;align-items:center}
    button,select,input[type="text"]{background:#fff;border:0;padding:8px 10px;border-radius:6px;color:#000;font-weight:600;cursor:pointer}
    button:active{transform:translateY(1px)}
    .status{display:flex;gap:12px;align-items:center;margin-left:12px;color:#fff;font-weight:600}
    .board{
      display:flex;flex-direction:column;gap:12px;
    }
    .top-row{display:flex;justify-content:space-between;gap:12px}
    .left-pile{
      display:flex;gap:12px;
      align-items:flex-start;
    }
    .piles-row{display:flex;gap:12px}
    .pile, .foundation{
      width:var(--card-width);min-height:var(--card-height);border-radius:var(--card-radius);position:relative;
      background:linear-gradient(180deg,#0d702f,#0b5a28);box-shadow:0 2px 6px rgba(0,0,0,0.5);
      padding:6px;box-sizing:border-box;
    }
    .pile.empty, .foundation.empty{border:2px dashed rgba(255,255,255,0.06);background:linear-gradient(180deg,#0d702f,#0b5a28)}
    .stack{position:relative;height:calc(var(--card-height) + 10px);width:var(--card-width)}
    .tableau{display:flex;gap:12px}
    .tableau .column{width:var(--card-width);min-height:300px}
    .card{
      width:var(--card-width);height:var(--card-height);
      border-radius:var(--card-radius);box-shadow:0 6px 14px rgba(0,0,0,0.5);
      position:absolute;left:0;top:0;cursor:pointer;user-select:none;
      display:flex;flex-direction:column;justify-content:space-between;padding:8px;box-sizing:border-box;
      background:#fff;color:var(--black);
      transition:transform 120ms ease, top 120ms ease, left 120ms ease;
      touch-action:none;
    }
    .card.face-down{background:linear-gradient(180deg,#183,#0b7);color:transparent;display:flex;align-items:center;justify-content:center;font-weight:900}
    .card .rank{font-weight:700}
    .card .suit{font-size:20px;line-height:1}
    .card.red{color:var(--red)}
    .meta{display:flex;gap:12px;align-items:center}
    .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.5);display:none;align-items:center;justify-content:center;padding:12px}
    .modal{background:#fff;color:#000;padding:18px;border-radius:10px;max-width:420px;width:100%}
    .modal h2{margin-top:0}
    .modal .actions{display:flex;gap:8px;margin-top:12px;justify-content:flex-end}
    .highscores-list{max-height:320px;overflow:auto}
    .drop-highlight{outline:3px dashed rgba(255,255,0,0.6);border-radius:8px}
    .ghost{position:fixed;pointer-events:none;z-index:9999;transform:translate(-50%,-50%);opacity:0.95}
    @media(max-width:900px){
      :root{--card-width:72px;--card-height:98px}
      .tableau .column{min-height:220px}
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <h1>Klondike Solitaire</h1>
      <div class="meta">
        <div class="status">Score: <span id="score">0</span></div>
        <div class="status">Moves: <span id="moves">0</span></div>
        <div class="status">Time: <span id="timer">00:00</span></div>
      </div>
      <div class="controls">
        <select id="drawMode" title="Draw mode">
          <option value="1">Draw 1</option>
          <option value="3">Draw 3</option>
        </select>
        <button id="newGameBtn">New Game</button>
        <button id="undoBtn">Undo</button>
        <button id="highscoresBtn">High Scores</button>
      </div>
    </header>

    <main class="board">
      <div class="top-row">
        <div class="left-pile">
          <div class="pile" id="stock"></div>
          <div class="pile" id="waste"></div>
        </div>
        <div class="piles-row" id="foundations">
          <!-- 4 foundations -->
        </div>
      </div>

      <section class="tableau" id="tableau">
        <!-- 7 columns -->
      </section>
    </main>
  </div>

  <!-- Win / enter name modal -->
  <div class="modal-backdrop" id="modalBackdrop">
    <div class="modal" id="modal">
      <h2 id="modalTitle">You won!</h2>
      <div id="modalBody"></div>
      <div class="actions">
        <button id="modalClose">Close</button>
      </div>
    </div>
  </div>

  <script>
  /***************
   * Utility
   ***************/
  const util = {
    randInt(n){ return Math.floor(Math.random()*n) },
    shuffle(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = this.randInt(i+1);
        [arr[i],arr[j]]=[arr[j],arr[i]];
      }
      return arr;
    },
    fmtTime(sec){
      const m = Math.floor(sec/60); const s = sec%60;
      return String(m).padStart(2,'0')+':'+String(s).padStart(2,'0');
    },
    clone(state){ return JSON.parse(JSON.stringify(state)) }
  };

  /**************
   * Storage (localStorage high scores)
   **************/
  const Storage = (function(){
    const KEY = 'solitaire_highscores_v1';
    function load(){ try{ return JSON.parse(localStorage.getItem(KEY)||'[]') }catch(e){return []} }
    function save(list){ localStorage.setItem(KEY, JSON.stringify(list)) }
    return {
      list(){ return load().sort((a,b)=>b.score - a.score).slice(0,50) },
      add(entry){ const all = load(); all.push(entry); save(all) },
      clear(){ save([]) }
    };
  })();

  /**************
   * Game logic
   **************/
  const Game = (function(){
    const SUITS=['♠','♥','♦','♣'];
    const RANKS=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
    function makeDeck(){
      const deck=[];
      for(const s of SUITS){
        for(let r=0;r<RANKS.length;r++){
          deck.push({suit:s,rank:RANKS[r],value:r+1,color: (s==='♥' || s==='♦') ? 'red' : 'black' });
        }
      }
      return deck;
    }

    function initialDeal(drawMode=1){
      const deck = makeDeck();
      util.shuffle(deck);
      const tableau = [];
      let idx = 0;
      for(let c=0;c<7;c++){
        const col = [];
        for(let k=0;k<=c;k++){
          const card = deck[idx++];
          card.faceUp = (k===c);
          col.push(card);
        }
        tableau.push(col);
      }
      const stock = [];
      for(;idx<deck.length;idx++){
        const c = deck[idx]; c.faceUp=false; stock.push(c);
      }
      return {
        tableau,
        foundations:[[],[],[],[]],
        stock,
        waste:[],
        drawMode: drawMode,
        score:0,
        moves:0,
        started:false,
        seconds:0,
        won:false
      };
    }

    function topFoundationSuitIndex(foundations, suit){
      const order = ['♠','♥','♦','♣'];
      return order.indexOf(suit);
    }

    function canMoveToFoundation(card, foundations){
      const idx = topFoundationSuitIndex(foundations, card.suit);
      if(idx===-1) return false;
      const pile = foundations[idx];
      if(pile.length===0) return card.value===1;
      return card.value === pile[pile.length-1].value + 1;
    }

    function canMoveToTableau(card, destCol){
      if(destCol.length===0) return card.value===13; // King
      const top = destCol[destCol.length-1];
      return (top.color !== card.color) && (top.value === card.value + 1);
    }

    function moveFromStock(state){
      if(state.stock.length===0){
        while(state.waste.length>0){
          const c = state.waste.pop(); c.faceUp=false; state.stock.push(c);
        }
        state.moves++;
        return true;
      } else {
        const n = state.drawMode || 1;
        for(let i=0;i<n && state.stock.length>0;i++){
          const c = state.stock.pop();
          c.faceUp = true;
          state.waste.push(c);
        }
        state.moves++;
        return true;
      }
    }

    function checkWin(state){
      return state.foundations.every(f=>f.length===13);
    }

    return {
      makeDeck, initialDeal, canMoveToFoundation, canMoveToTableau, moveFromStock, checkWin
    };
  })();

  /*************
   * Undo manager (snapshots)
   *************/
  const Undo = (function(){
    let stack = [];
    function clear(){ stack = [] }
    function push(state){ stack.push(util.clone(state)) }
    function undo(getState,setState){
      if(stack.length===0) return false;
      const snap = stack.pop();
      setState(snap);
      return true;
    }
    return {push,undo,clear};
  })();

  /****************
   * Renderer & UI + Drag-and-Drop
   ****************/
  (function(){
    // DOM refs
    const $stock = document.getElementById('stock');
    const $waste = document.getElementById('waste');
    const $foundations = document.getElementById('foundations');
    const $tableau = document.getElementById('tableau');
    const $score = document.getElementById('score');
    const $moves = document.getElementById('moves');
    const $timer = document.getElementById('timer');
    const $drawMode = document.getElementById('drawMode');
    const $newGameBtn = document.getElementById('newGameBtn');
    const $undoBtn = document.getElementById('undoBtn');
    const $highscoresBtn = document.getElementById('highscoresBtn');
    const $modalBackdrop = document.getElementById('modalBackdrop');
    const $modal = document.getElementById('modal');
    const $modalTitle = document.getElementById('modalTitle');
    const $modalBody = document.getElementById('modalBody');
    const $modalClose = document.getElementById('modalClose');

    let state = Game.initialDeal(1);
    let timerInterval = null;
    let selected = null; // selection for click moves
    let dragState = null; // {origin:{type,col,index}, movingCards:[], ghostEl, pointerId}
    let startedOnce=false;

    function startTimer(){
      if(timerInterval) return;
      timerInterval = setInterval(()=>{
        state.seconds++;
        $timer.textContent = util.fmtTime(state.seconds);
      },1000);
    }
    function stopTimer(){
      if(timerInterval){ clearInterval(timerInterval); timerInterval=null; }
    }

    function setState(newState){
      state = newState;
      renderAll();
    }

    function newGame(){
      Undo.clear();
      state = Game.initialDeal(parseInt($drawMode.value,10));
      state.started=false; state.won=false; state.score=0; state.moves=0; state.seconds=0;
      renderAll();
      selected = null;
      dragState = null;
      startedOnce = false;
      stopTimer();
      $timer.textContent = util.fmtTime(0);
    }

    function pushUndo(){
      const snap = {
        tableau: util.clone(state.tableau),
        foundations: util.clone(state.foundations),
        stock: util.clone(state.stock),
        waste: util.clone(state.waste),
        score: state.score,
        moves: state.moves,
        seconds: state.seconds,
        drawMode: state.drawMode,
        started: state.started
      };
      Undo.push(snap);
    }

    function finishIfWon(){
      if(Game.checkWin(state)){
        state.won=true;
        stopTimer();
        renderAll();
        showWinModal();
      }
    }

    // return true if any legal move exists from the current state
    function hasAnyLegalMoves(){
      // waste -> foundation / tableau
      if(state.waste.length>0){
        const w = state.waste[state.waste.length-1];
        if(Game.canMoveToFoundation(w, state.foundations)) return true;
        for(let c=0;c<7;c++){
          if(Game.canMoveToTableau(w, state.tableau[c])) return true;
        }
      }
      // tableau -> foundation / tableau
      for(let c=0;c<7;c++){
        const col = state.tableau[c];
        for(let i=0;i<col.length;i++){
          const card = col[i];
          if(!card.faceUp) continue;
          // single-card to foundation (only top card matters for foundation)
          if(i === col.length - 1 && Game.canMoveToFoundation(card, state.foundations)) return true;
          // try moving this face-up card (and stack beneath it) to other tableau columns
          for(let d=0;d<7;d++){
            if(d===c) continue;
            if(Game.canMoveToTableau(card, state.tableau[d])) return true;
          }
        }
      }
      return false;
    }

    function checkForLoss(){
      if(state.won) return;
      // if there are any legal moves, not a loss
      if(hasAnyLegalMoves()) return;
      // allow a chance to draw from stock if available
      if(state.stock.length>0) return;
      // No stock and no legal moves -> player loses
      const html = '<div>No legal moves remain. You cannot move any cards through the deck.</div>' +
        '<div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end">' +
        '<button id="loseNewGame">New Game</button>' +
        '<button id="loseDismiss">Dismiss</button>' +
        '</div>';
      openModal('No moves left', html, false);
      document.getElementById('loseNewGame').addEventListener('click', ()=>{ closeModal(); newGame(); });
      document.getElementById('loseDismiss').addEventListener('click', ()=>{ closeModal(); });
    }

    function clearChildren(node){ while(node.firstChild) node.removeChild(node.firstChild) }

    // Render helpers
    function renderCardElement(card, opts = {}) {
      // opts: {col, index, location:'waste'|'foundation'|'tableau'}
      const el = document.createElement('div');
      el.className = 'card' + (card.faceUp ? '' : ' face-down') + (card.color==='red' ? ' red' : '');
      if(!card.faceUp){
        el.textContent = '';
        return el;
      }
      const top = document.createElement('div');
      top.innerHTML = '<div class="rank">'+card.rank+'</div><div class="suit">'+card.suit+'</div>';
      const bottom = document.createElement('div');
      bottom.style.transform='rotate(180deg)'; bottom.innerHTML = '<div class="rank">'+card.rank+'</div><div class="suit">'+card.suit+'</div>';
      el.appendChild(top); el.appendChild(bottom);

      // attach metadata
      if(opts.location === 'waste'){
        el.dataset.location = 'waste';
      } else if(opts.location === 'foundation'){
        el.dataset.location = 'foundation';
        el.dataset.foundationIndex = opts.foundationIndex;
      } else if(opts.location === 'tableau'){
        el.dataset.location = 'tableau';
        el.dataset.col = opts.col;
        el.dataset.index = opts.index;
      }

      // Click handler (select / auto-move)
      el.addEventListener('click', (ev)=>{
        ev.stopPropagation();
        if(!card.faceUp) return;

        // Helper: attempt to move a single card (or stack) to any tableau column (left-to-right)
        function tryMoveToAnyTableau(singleCard, origin){
          for(let d=0; d<7; d++){
            // skip moving to same column
            if(origin && origin.type === 'tableau' && origin.col === d) continue;
            if(Game.canMoveToTableau(singleCard, state.tableau[d])){
              // perform move
              if(origin.type === 'waste'){
                const c = state.waste.pop();
                state.tableau[d].push(c);
              } else if(origin.type === 'tableau'){
                const moving = state.tableau[origin.col].slice(origin.index);
                state.tableau[origin.col].splice(origin.index);
                state.tableau[d].push(...moving);
              }
              state.moves++; state.score += 5;
              if(!state.started){ state.started=true; startTimer() }
              checkForFlip(origin);
              renderAll();
              finishIfWon();
              checkForLoss();
              return true;
            }
          }
          return false;
        }

        // If clicking waste card - try foundation first, then any tableau column
        if(el.dataset.location === 'waste'){
          const from = {type:'waste',index:state.waste.length-1};
          if(Game.canMoveToFoundation(card, state.foundations)){
            pushUndo();
            const idx = ['♠','♥','♦','♣'].indexOf(card.suit);
            state.waste.pop();
            state.foundations[idx].push(card);
            state.moves++; state.score += 10;
            if(!state.started){ state.started=true; startTimer() }
            renderAll(); finishIfWon(); checkForLoss(); return;
          }
          // try moving automatically to a tableau column
          if(tryMoveToAnyTableau(card, from)) return;
          // else select waste
          selected = {type:'waste',index:state.waste.length-1,card};
          highlightSelection();
          return;
        }

        // If clicking a tableau card / stack
        if(el.dataset.location === 'tableau'){
          const col = parseInt(el.dataset.col,10);
          const index = parseInt(el.dataset.index,10);
          const colArr = state.tableau[col];
          const isTop = index === colArr.length - 1;

          // if top card, try foundation first
          if(isTop && Game.canMoveToFoundation(card, state.foundations)){
            pushUndo();
            const idx = ['♠','♥','♦','♣'].indexOf(card.suit);
            state.tableau[col].splice(index);
            state.foundations[idx].push(card);
            state.moves++; state.score += 10;
            if(!state.started){ state.started=true; startTimer() }
            checkForFlip({type:'tableau',col,index});
            renderAll(); finishIfWon(); checkForLoss(); return;
          }

          // try auto-move the stack (or single card) to any valid tableau destination
          const origin = {type:'tableau',col,index};
          const topCard = state.tableau[col][index];
          if(tryMoveToAnyTableau(topCard, origin)) return;

          // otherwise select stack for manual move
          selected = {type:'tableau',col,index,card};
          highlightSelection();
          return;
        }

        // foundation click handled elsewhere (via foundation container)
      });

      // Pointer events for drag-and-drop (only for face-up)
      el.addEventListener('pointerdown', (ev)=>{
        if(!card.faceUp) return;
        ev.preventDefault();
        ev.stopPropagation();
        // record drag origin and cards to move
        let origin;
        let movingCards = [];
        if(opts.location === 'waste'){
          origin = {type:'waste',index:state.waste.length-1};
          movingCards = [ state.waste[state.waste.length-1] ];
        } else if(opts.location === 'tableau'){
          origin = {type:'tableau',col:opts.col,index:opts.index};
          movingCards = state.tableau[opts.col].slice(opts.index);
        } else {
          return; // don't drag from foundations
        }

        // create ghost (show proper suit and color, and count if moving multiple cards)
        const ghost = document.createElement('div');
        ghost.className = 'card ghost';
        // render a compact visual of the moving stack (show top card suit with color)
        const topCard = movingCards[0];
        const suitHtml = `<span class="suit" style="font-size:20px;${topCard.color === 'red' ? 'color:var(--red);' : 'color:var(--black);'}">${topCard.suit}</span>`;
        let countHtml = '';
        if(movingCards.length > 1){
          countHtml = `<div style="font-size:12px;opacity:0.9;margin-top:4px">+${movingCards.length - 1} cards</div>`;
        }
        ghost.innerHTML = `<div style="padding:8px;font-weight:800;font-size:16px;text-align:center">${topCard.rank} ${suitHtml}${countHtml}</div>`;
        document.body.appendChild(ghost);

        dragState = {
          origin,
          movingCards,
          ghostEl: ghost,
          pointerId: ev.pointerId
        };
        // initial position
        moveGhost(ev.clientX, ev.clientY);

        // capture pointer on the element so we receive move/up events
        (ev.target).setPointerCapture(ev.pointerId);

        // snapshot before actual move for undo (we'll only commit if move occurs)
        pushUndo();
      });

      return el;
    }

    function moveGhost(x, y){
      if(!dragState || !dragState.ghostEl) return;
      const g = dragState.ghostEl;
      g.style.left = x + 'px';
      g.style.top = y + 'px';
    }

    function clearDropHighlights(){
      document.querySelectorAll('.drop-highlight').forEach(el=>{
        el.classList.remove('drop-highlight');
      });
    }

    function performDropAt(x, y){
      if(!dragState) return false;
      const elem = document.elementFromPoint(x, y);
      if(!elem) return false;
      const foundationEl = elem.closest('.foundation');
      const columnEl = elem.closest('.column');
      // moving stack and top card
      const movingStack = dragState.movingCards;
      const topCard = movingStack[0];
      if(foundationEl){
        const fIndex = parseInt(foundationEl.dataset.foundationIndex,10);
        // only single-card moves to foundation allowed
        if(movingStack.length === 1 && Game.canMoveToFoundation(topCard, state.foundations)){
          // ensure suit matches foundation index
          const suitIndex = ['♠','♥','♦','♣'].indexOf(topCard.suit);
          if(suitIndex === fIndex){
            // remove from origin
            if(dragState.origin.type === 'waste'){
              state.waste.pop();
            } else if(dragState.origin.type === 'tableau'){
              state.tableau[dragState.origin.col].splice(dragState.origin.index);
            }
            state.foundations[fIndex].push(topCard);
            state.moves++; state.score += 10;
            if(!state.started){ state.started=true; startTimer() }
            checkForFlip(dragState.origin);
            finishIfWon();
            return true;
          }
        }
        return false;
      } else if(columnEl){
        // get destination column index
        const destIndex = Array.from($tableau.children).indexOf(columnEl);
        if(destIndex < 0) return false;
        // can move if topCard can be placed onto dest column
        if(Game.canMoveToTableau(topCard, state.tableau[destIndex])){
          // perform move
          if(dragState.origin.type === 'waste'){
            const c = state.waste.pop();
            state.tableau[destIndex].push(c);
          } else if(dragState.origin.type === 'tableau'){
            const moving = state.tableau[dragState.origin.col].slice(dragState.origin.index);
            state.tableau[dragState.origin.col].splice(dragState.origin.index);
            state.tableau[destIndex].push(...moving);
          }
          state.moves++; state.score += 5;
          if(!state.started){ state.started=true; startTimer() }
          checkForFlip(dragState.origin);
          return true;
        }
        return false;
      }
      return false;
    }

    function checkForFlip(from){
      if(from && from.type==='tableau'){
        const col = state.tableau[from.col];
        if(col.length>0){
          const top = col[col.length-1];
          if(!top.faceUp){ top.faceUp=true }
        }
      }
    }

    function highlightSelection(){
      renderAll();
      if(!selected) return;
      if(selected.type==='waste'){
        const el = $waste.querySelector('.card');
        if(el) el.style.outline='3px solid rgba(255,255,0,0.8)';
      } else if(selected.type==='tableau'){
        const col = $tableau.children[selected.col];
        if(!col) return;
        const container = col.querySelector('div');
        const nodes = container.querySelectorAll('.card');
        for(let i=selected.index;i<nodes.length;i++){
          nodes[i].style.outline='3px solid rgba(255,255,0,0.8)';
        }
      }
    }

    // Main render function
    function renderAll(){
      // status
      $score.textContent = state.score;
      $moves.textContent = state.moves;
      $timer.textContent = util.fmtTime(state.seconds);

      // foundations - recreate nodes (show suit marker on empty slots)
      clearChildren($foundations);
      for(let i=0;i<4;i++){
        const f = document.createElement('div');
        f.className = 'foundation ' + (state.foundations[i].length===0 ? 'empty':'');
        f.dataset.foundationIndex = i;
        if(state.foundations[i].length>0){
          const topCard = state.foundations[i][state.foundations[i].length-1];
          const el = renderCardElement(topCard, {location:'foundation',foundationIndex:i});
          f.appendChild(el);
        } else {
          // show suit marker on empty slot so user knows which foundation is which
          const SUIT_ORDER = ['♠','♥','♦','♣'];
          const marker = document.createElement('div');
          marker.style.fontSize = '28px';
          marker.style.opacity = '0.45';
          marker.style.textAlign = 'center';
          marker.style.lineHeight = getComputedStyle(f).minHeight || '1';
          // color red for hearts/diamonds
          if(SUIT_ORDER[i] === '♥' || SUIT_ORDER[i] === '♦'){
            marker.style.color = 'var(--red)';
          } else {
            marker.style.color = 'var(--black)';
          }
          marker.textContent = SUIT_ORDER[i];
          f.appendChild(marker);
        }
        $foundations.appendChild(f);
      }

      // stock
      clearChildren($stock);
      const stockPile = document.createElement('div');
      stockPile.className='stack';
      if(state.stock.length===0){
        const empty = document.createElement('div'); empty.className='pile empty'; stockPile.appendChild(empty);
      } else {
        const back = document.createElement('div'); back.className='card face-down'; back.style.position='relative';
        stockPile.appendChild(back);
      }
      $stock.appendChild(stockPile);

      // waste
      clearChildren($waste);
      if(state.waste.length>0){
        const top = state.waste[state.waste.length-1];
        const el = renderCardElement(top, {location:'waste'});
        // add click handler already inside renderCardElement
        $waste.appendChild(el);
      } else {
        const empty = document.createElement('div'); empty.className='pile empty'; $waste.appendChild(empty);
      }

      // tableau
      clearChildren($tableau);
      for(let c=0;c<7;c++){
        const col = document.createElement('div'); col.className='column';
        const colStack = state.tableau[c];
        const container = document.createElement('div'); container.style.position='relative'; container.style.minHeight='260px';
        if(colStack.length===0){
          const empty = document.createElement('div'); empty.className='pile empty'; empty.style.height = '120px';
          empty.dataset.col=c;
          empty.addEventListener('click', ()=> onColumnClicked(c));
          container.appendChild(empty);
        } else {
          for(let i=0;i<colStack.length;i++){
            const card = colStack[i];
            const el = renderCardElement(card, {location:'tableau',col:c,index:i});
            el.style.top = (i*28) + 'px';
            el.style.position = 'absolute';
            container.appendChild(el);
          }
        }
        col.appendChild(container);
        $tableau.appendChild(col);
      }

      // attach foundation click handlers for click-to-move
      document.querySelectorAll('.foundation').forEach(fEl=>{
        fEl.onclick = function(ev){
          ev.stopPropagation();
          const idx = parseInt(fEl.dataset.foundationIndex,10);
          if(Number.isNaN(idx)) return;
          onFoundationClicked(idx);
        };
      });
    }

    /*******************
     * Input handlers (click-based)
     *******************/
    function onStockClicked(){
      if(!state.started){ state.started=true; startTimer() }
      pushUndo();
      Game.moveFromStock(state);
      renderAll();
      // after drawing, check if there are any legal moves left; if stock is empty and none, show loss
      checkForLoss();
    }

    function onColumnClicked(destCol){
      if(!selected) return;
      if(selected.type==='waste'){
        const card = state.waste[state.waste.length-1];
        if(Game.canMoveToTableau(card, state.tableau[destCol])){
          pushUndo();
          const moving = state.waste.pop();
          state.tableau[destCol].push(moving);
          state.moves++; state.score += 5;
          if(!state.started){ state.started=true; startTimer() }
          checkForFlip(null);
          renderAll();
          selected=null; return;
        } else {
          selected=null; renderAll(); return;
        }
      } else if(selected.type==='tableau'){
        const colArr = state.tableau[selected.col];
        const movingStack = colArr.slice(selected.index);
        const topCard = movingStack[0];
        if(Game.canMoveToTableau(topCard, state.tableau[destCol])){
          pushUndo();
          state.tableau[selected.col].splice(selected.index);
          state.tableau[destCol].push(...movingStack);
          state.moves++; state.score += 5;
          if(!state.started){ state.started=true; startTimer() }
          checkForFlip({type:'tableau',col:selected.col,index:selected.index});
          renderAll();
          selected=null; return;
        } else { selected=null; renderAll(); return; }
      }
    }

    function onFoundationClicked(fIndex){
      if(!selected) return;
      if(selected.type==='waste'){
        const card = state.waste[state.waste.length-1];
        if(Game.canMoveToFoundation(card, state.foundations)){
          const idx = ['♠','♥','♦','♣'].indexOf(card.suit);
          if(idx===fIndex){
            pushUndo();
            state.waste.pop();
            state.foundations[fIndex].push(card);
            state.moves++; state.score += 10;
            if(!state.started){ state.started=true; startTimer() }
            renderAll(); selected=null; finishIfWon(); return;
          }
        }
      } else if(selected.type==='tableau'){
        const colArr = state.tableau[selected.col];
        const card = colArr[selected.index];
        if(Game.canMoveToFoundation(card, state.foundations)){
          const idx = ['♠','♥','♦','♣'].indexOf(card.suit);
          if(idx===fIndex){
            pushUndo();
            state.tableau[selected.col].splice(selected.index);
            state.foundations[fIndex].push(card);
            state.moves++; state.score+=10;
            checkForFlip({type:'tableau',col:selected.col,index:selected.index});
            renderAll(); selected=null; finishIfWon(); return;
          }
        }
      }
      selected=null; renderAll();
    }

    // Attach top-level listeners (stock, waste)
    $stock.addEventListener('click', onStockClicked);
    $waste.addEventListener('click', (ev)=> {
      ev.stopPropagation();
      // If click lands on an inner card it's already handled by that card's click.
      // This handler is a fallback when clicking empty area.
      if(state.waste.length===0) return;
      selected = {type:'waste',index:state.waste.length-1,card:state.waste[state.waste.length-1]};
      highlightSelection();
    });

    $newGameBtn.addEventListener('click', ()=> { newGame(); });
    $undoBtn.addEventListener('click', ()=> {
      Undo.undo(()=>util.clone(state), (snap)=>{
        if(!snap) return;
        state.tableau = snap.tableau;
        state.foundations = snap.foundations;
        state.stock = snap.stock;
        state.waste = snap.waste;
        state.score = snap.score;
        state.moves = snap.moves;
        state.seconds = snap.seconds;
        state.drawMode = snap.drawMode;
        state.started = snap.started;
        if(state.started && !timerInterval) startTimer();
        renderAll();
      });
      selected=null;
    });

    // foundation clicks delegated in renderAll

    // high scores modal
    $highscoresBtn.addEventListener('click', ()=> {
      showHighscores();
    });

    $modalClose.addEventListener('click', ()=> {
      closeModal();
    });

    function openModal(title, bodyHTML, closable=true){
      $modalTitle.textContent = title;
      $modalBody.innerHTML = bodyHTML;
      $modalBackdrop.style.display='flex';
      $modalClose.style.display = closable ? 'inline-block':'none';
    }
    function closeModal(){ $modalBackdrop.style.display='none' }

    function showHighscores(){
      const list = Storage.list();
      if(list.length===0){
        openModal('High Scores','<div>No scores yet. Finish a game to add a score.</div>');
        return;
      }
      let html = '<div class="highscores-list"><table style="width:100%;color:#000"><thead><tr><th>Name</th><th>Score</th><th>Moves</th><th>Time</th><th>Date</th></tr></thead><tbody>';
      for(const s of list){
        html += `<tr><td>${escapeHtml(s.name||'Anonymous')}</td><td>${s.score}</td><td>${s.moves}</td><td>${util.fmtTime(s.seconds)}</td><td>${new Date(s.date).toLocaleString()}</td></tr>`;
      }
      html += '</tbody></table></div>';
      html += '<div style="display:flex;gap:8px;margin-top:10px;justify-content:flex-end"><button id="clearScores">Clear</button></div>';
      openModal('High Scores', html);
      document.getElementById('clearScores').addEventListener('click', ()=> {
        if(confirm('Clear all saved high scores?')){ Storage.clear(); closeModal(); }
      });
    }

    function showWinModal(){
      let html = `<div>Congratulations! You finished the game.<p>Score: ${state.score}<br/>Moves: ${state.moves}<br/>Time: ${util.fmtTime(state.seconds)}</p></div>`;
      html += `<div style="margin-top:8px"><input id="playerName" placeholder="Your name" style="width:100%;padding:8px;border-radius:6px;border:1px solid #ccc" /></div>`;
      html += `<div style="display:flex;gap:8px;margin-top:12px;justify-content:flex-end"><button id="saveScoreBtn">Save</button><button id="dismissWin">Dismiss</button></div>`;
      openModal('You won!', html, false);
      document.getElementById('saveScoreBtn').addEventListener('click', ()=>{
        const name = document.getElementById('playerName').value || 'Anonymous';
        Storage.add({name,score:state.score,moves:state.moves,seconds:state.seconds,date:Date.now(),drawMode:state.drawMode});
        closeModal();
      });
      document.getElementById('dismissWin').addEventListener('click', ()=> {
        closeModal();
      });
    }

    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=>({ '&':'&','<':'<','>':'>','"':'"',"'":'&#39;' })[c]) }

    // Global pointermove/up for drag handling
    window.addEventListener('pointermove', (ev)=>{
      if(!dragState) return;
      moveGhost(ev.clientX, ev.clientY);
      // highlight potential drop targets
      clearDropHighlights();
      const el = document.elementFromPoint(ev.clientX, ev.clientY);
      if(!el) return;
      const foundationEl = el.closest('.foundation');
      const columnEl = el.closest('.column');
      if(foundationEl) foundationEl.classList.add('drop-highlight');
      if(columnEl) columnEl.classList.add('drop-highlight');
    });

    window.addEventListener('pointerup', (ev)=>{
      if(!dragState) return;
      // finalize drop attempt
      const success = performDropAt(ev.clientX, ev.clientY);
      // remove ghost
      if(dragState.ghostEl && dragState.ghostEl.parentNode) dragState.ghostEl.parentNode.removeChild(dragState.ghostEl);
      dragState = null;
      clearDropHighlights();
      renderAll();
      if(success) finishIfWon();
      // if no success, or even after successful move, verify loss condition (safe-guard)
      checkForLoss();
    });

    // initial render and attach foundation/tableau slots
    function init(){
      for(let i=0;i<4;i++){
        const f = document.createElement('div');
        f.className = 'foundation empty'; f.dataset.foundationIndex = i;
        $foundations.appendChild(f);
      }
      for(let i=0;i<7;i++){
        const col = document.createElement('div'); col.className='column';
        $tableau.appendChild(col);
      }
      renderAll();
    }

    init();

    // keyboard
    window.addEventListener('keydown',(e)=>{
      if((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='z'){ e.preventDefault(); $undoBtn.click(); }
      if(e.key==='n'){ $newGameBtn.click() }
      if(e.key==='h'){ $highscoresBtn.click() }
    });

    // expose newGame for external calls
    window.SolitareApp = {
      newGame: newGame
    };
  })();
  </script>
</body>
</html>
